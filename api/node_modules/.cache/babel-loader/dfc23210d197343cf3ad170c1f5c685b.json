{"ast":null,"code":"'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport { VERSION } from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\nconst {\n  http: httpFollow,\n  https: httpsFollow\n} = followRedirects;\nconst isHttps = /https:?/;\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\n\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\n\n\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n\n  if (!proxy && proxy !== false) {\n    const proxyUrl = getProxyForUrl(location);\n\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n\n      const base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost; // Replace 'host' since options is not a URL object\n\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n/*eslint consistent-return:0*/\n\n\nexport default function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    let data = config.data;\n    const responseType = config.responseType;\n    const responseEncoding = config.responseEncoding;\n    const method = config.method.toUpperCase();\n    let isFinished;\n    let isDone;\n    let rejected = false;\n    let req; // temporary internal emitter until the AxiosRequest class will be implemented\n\n    const emitter = new EventEmitter();\n\n    function onFinished() {\n      if (isFinished) return;\n      isFinished = true;\n\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    function done(value, isRejected) {\n      if (isDone) return;\n      isDone = true;\n\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n\n      isRejected ? rejectPromise(value) : resolvePromise(value);\n    }\n\n    const resolve = function resolve(value) {\n      done(value);\n    };\n\n    const reject = function reject(value) {\n      done(value, true);\n    };\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    } // Parse url\n\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          data = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: {},\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize(); // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n    const onDownloadProgress = config.onDownloadProgress;\n    const onUploadProgress = config.onUploadProgress;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined; // support for https://www.npmjs.com/package/form-data api\n\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));\n      } // Add Content-Length header if data exists\n\n\n      headers.set('Content-Length', data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));\n      }\n    }\n\n    const contentLength = +headers.getContentLength();\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {\n          objectMode: false\n        });\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        length: utils.toFiniteNumber(contentLength),\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n      onUploadProgress && data.on('progress', progress => {\n        onUploadProgress(Object.assign(progress, {\n          upload: true\n        }));\n      });\n    } // HTTP basic authentication\n\n\n    let auth = undefined;\n\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n    let path;\n\n    try {\n      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set('Accept-Encoding', 'gzip, deflate, br', false);\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth,\n      protocol,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    } // Create the request\n\n\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n      const streams = [res]; // uncompress the response body transparently if required\n\n      let responseStream = res; // return the last request in case of redirects\n\n      const lastRequest = res.req || req; // if decompress disabled we should not decompress\n\n      if (config.decompress !== false) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (data && data.length === 0 && res.headers['content-encoding']) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch (res.headers['content-encoding']) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'compress':\n          case 'deflate':\n            // add the unzipper to the body stream processing pipeline\n            streams.push(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n\n          case 'br':\n            if (isBrotliSupported) {\n              streams.push(zlib.createBrotliDecompress());\n              delete res.headers['content-encoding'];\n            }\n\n        }\n      }\n\n      if (onDownloadProgress) {\n        const responseLength = +res.headers['content-length'];\n        const transformStream = new AxiosTransformStream({\n          length: utils.toFiniteNumber(responseLength),\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n        onDownloadProgress && transformStream.on('progress', progress => {\n          onDownloadProgress(Object.assign(progress, {\n            download: true\n          }));\n        });\n        streams.push(transformStream);\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest);\n          responseStream.destroy(err);\n          reject(err);\n        });\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    }); // set tcp keep alive to prevent drop connection by peer\n\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n        return;\n      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n\n\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n\n        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n        abort();\n      });\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n      data.on('end', () => {\n        ended = true;\n      });\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\nexport const __setProxy = setProxy;","map":{"version":3,"sources":["C:/Users/DELL/Desktop/vscode/programs/c.c/codes/client/node_modules/axios/lib/adapters/http.js"],"names":["utils","settle","buildFullPath","buildURL","getProxyForUrl","http","https","followRedirects","zlib","VERSION","transitionalDefaults","AxiosError","CanceledError","platform","fromDataURI","stream","AxiosHeaders","AxiosTransformStream","EventEmitter","isBrotliSupported","isFunction","createBrotliDecompress","httpFollow","httpsFollow","isHttps","supportedProtocols","protocols","map","protocol","dispatchBeforeRedirect","options","beforeRedirects","proxy","config","setProxy","configProxy","location","proxyUrl","URL","username","auth","password","base64","Buffer","from","toString","headers","host","hostname","port","proxyHost","path","includes","beforeRedirect","redirectOptions","href","httpAdapter","Promise","dispatchHttpRequest","resolvePromise","rejectPromise","data","responseType","responseEncoding","method","toUpperCase","isFinished","isDone","rejected","req","emitter","onFinished","cancelToken","unsubscribe","abort","signal","removeEventListener","removeAllListeners","done","value","isRejected","resolve","reject","reason","emit","type","once","subscribe","aborted","addEventListener","fullPath","baseURL","url","parsed","convertedData","status","statusText","Blob","env","err","ERR_BAD_REQUEST","stripBOM","Readable","indexOf","normalize","set","onDownloadProgress","onUploadProgress","maxRate","maxUploadRate","undefined","maxDownloadRate","isFormData","getHeaders","isStream","isBuffer","isArrayBuffer","Uint8Array","isString","length","maxBodyLength","contentLength","getContentLength","isArray","objectMode","pipeline","toFiniteNumber","noop","on","progress","Object","assign","upload","urlUsername","urlPassword","delete","pathname","search","params","paramsSerializer","replace","customErr","Error","message","exists","toJSON","agents","httpAgent","httpsAgent","socketPath","transport","isHttpsRequest","test","agent","maxRedirects","Infinity","insecureHTTPParser","request","handleResponse","res","destroyed","streams","responseStream","lastRequest","decompress","push","createUnzip","responseLength","transformStream","download","offListeners","finished","response","statusCode","statusMessage","responseBuffer","totalResponseBytes","handleStreamData","chunk","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","handleStreamError","handleStreamEnd","responseData","concat","handleRequestError","handleRequestSocket","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","ended","errored","pipe","end","__setProxy"],"mappings":"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","sourcesContent":["'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport {getProxyForUrl} from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\n/*eslint consistent-return:0*/\nexport default function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    let data = config.data;\n    const responseType = config.responseType;\n    const responseEncoding = config.responseEncoding;\n    const method = config.method.toUpperCase();\n    let isFinished;\n    let isDone;\n    let rejected = false;\n    let req;\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    function onFinished() {\n      if (isFinished) return;\n      isFinished = true;\n\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    function done(value, isRejected) {\n      if (isDone) return;\n\n      isDone = true;\n\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n\n      isRejected ? rejectPromise(value) : resolvePromise(value);\n    }\n\n    const resolve = function resolve(value) {\n      done(value);\n    };\n\n    const reject = function reject(value) {\n      done(value, true);\n    };\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          data = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: {},\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const onDownloadProgress = config.onDownloadProgress;\n    const onUploadProgress = config.onUploadProgress;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for https://www.npmjs.com/package/form-data api\n    if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.set('Content-Length', data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = +headers.getContentLength();\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        length: utils.toFiniteNumber(contentLength),\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', progress => {\n        onUploadProgress(Object.assign(progress, {\n          upload: true\n        }));\n      });\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set('Accept-Encoding', 'gzip, deflate, br', false);\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      // uncompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (data && data.length === 0 && res.headers['content-encoding']) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'compress':\n        case 'deflate':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip());\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress());\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      if (onDownloadProgress) {\n        const responseLength = +res.headers['content-length'];\n\n        const transformStream = new AxiosTransformStream({\n          length: utils.toFiniteNumber(responseLength),\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', progress => {\n          onDownloadProgress(Object.assign(progress, {\n            download: true\n          }));\n        });\n\n        streams.push(transformStream);\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\n\nexport const __setProxy = setProxy;"]},"metadata":{},"sourceType":"module"}